from flask import Flask, request
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_cors import CORS
import random
import string
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'durak_secret_key_2025')

# CORS
CORS(app, resources={
    r"/*": {
        "origins": "*",
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

# Socket.IO —Å —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
socketio = SocketIO(
    app,
    cors_allowed_origins="*",
    async_mode='threading',
    logger=True,
    engineio_logger=True,
    ping_timeout=60,
    ping_interval=25,
    max_http_buffer_size=1000000,
    transports=['websocket', 'polling']
)

# –î–∞–Ω—ñ –≥—Ä–∏
game_rooms = {}

# –ö–∞—Ä—Ç–∏
SUITS = ['hearts', 'diamonds', 'clubs', 'spades']
VALUES = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']

def generate_room_code():
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))

def create_deck():
    deck = []
    for suit in SUITS:
        for value in VALUES:
            deck.append({'suit': suit, 'value': value})
    random.shuffle(deck)
    return deck

def card_value(card, trump_suit):
    value_order = {'6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}
    base_value = value_order[card['value']]
    if card['suit'] == trump_suit:
        return base_value + 100
    return base_value

def can_beat(attack_card, defense_card, trump_suit):
    if defense_card['suit'] == attack_card['suit']:
        return card_value(defense_card, trump_suit) > card_value(attack_card, trump_suit)
    elif defense_card['suit'] == trump_suit:
        return True
    return False

@app.route('/')
def index():
    return {
        'status': '–î—É—Ä–∞–∫ —Å–µ—Ä–≤–µ—Ä –ø—Ä–∞—Ü—é—î!',
        'version': '2.0',
        'active_rooms': len(game_rooms)
    }

@app.route('/health')
def health():
    return {
        'status': 'ok',
        'rooms': len(game_rooms),
        'total_players': sum(len(room.get('players', [])) for room in game_rooms.values())
    }

@socketio.on('connect')
def handle_connect():
    print(f'‚úÖ –ö–ª—ñ—î–Ω—Ç –ø—ñ–¥–∫–ª—é—á–∏–≤—Å—è: {request.sid}')
    return True

@socketio.on('disconnect')
def handle_disconnect():
    print(f'‚ùå –ö–ª—ñ—î–Ω—Ç –≤—ñ–¥–∫–ª—é—á–∏–≤—Å—è: {request.sid}')
    
    # –í–∏–¥–∞–ª–µ–Ω–Ω—è –≥—Ä–∞–≤—Ü—è –∑ –∫—ñ–º–Ω–∞—Ç
    for room_code, room_data in list(game_rooms.items()):
        players = room_data.get('players', [])
        player_found = None
        
        for player in players:
            if player['sid'] == request.sid:
                player_found = player
                players.remove(player)
                break
        
        if player_found:
            socketio.emit('player_left', {
                'player_name': player_found['name'],
                'players': [{'name': p['name'], 'card_count': len(p.get('hand', []))} for p in players]
            }, room=room_code)
            
            if len(players) == 0:
                del game_rooms[room_code]
                print(f'üóëÔ∏è –ö—ñ–º–Ω–∞—Ç–∞ {room_code} –≤–∏–¥–∞–ª–µ–Ω–∞ (–ø—É—Å—Ç–∞)')

@socketio.on('create_room')
def handle_create_room(data):
    try:
        room_code = generate_room_code()
        player_name = data.get('player_name', '–ì—Ä–∞–≤–µ—Ü—å')
        
        game_rooms[room_code] = {
            'host': request.sid,
            'players': [{
                'sid': request.sid,
                'name': player_name,
                'hand': [],
                'connected': True
            }],
            'game_started': False,
            'deck': [],
            'trump_suit': '',
            'table_cards': [],
            'current_turn': 0,
            'attacker_index': 0,
            'defender_index': 1
        }
        
        join_room(room_code)
        emit('room_created', {'room_code': room_code})
        print(f'üéÆ –ö—ñ–º–Ω–∞—Ç–∞ —Å—Ç–≤–æ—Ä–µ–Ω–∞: {room_code} | –•–æ—Å—Ç: {player_name}')
        
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫—ñ–º–Ω–∞—Ç–∏: {e}')
        emit('error', {'message': '–ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫—ñ–º–Ω–∞—Ç–∏'})

@socketio.on('join_room')
def handle_join_room(data):
    try:
        room_code = data.get('room_code', '').upper()
        player_name = data.get('player_name', '–ì—Ä–∞–≤–µ—Ü—å')
        
        if room_code not in game_rooms:
            emit('error', {'message': '–ö—ñ–º–Ω–∞—Ç—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ'})
            return
        
        room = game_rooms[room_code]
        
        if len(room['players']) >= 5:
            emit('error', {'message': '–ö—ñ–º–Ω–∞—Ç–∞ –ø–æ–≤–Ω–∞ (–º–∞–∫—Å–∏–º—É–º 5 –≥—Ä–∞–≤—Ü—ñ–≤)'})
            return
        
        if room['game_started']:
            emit('error', {'message': '–ì—Ä–∞ –≤–∂–µ –ø–æ—á–∞–ª–∞—Å—è'})
            return
        
        player = {
            'sid': request.sid,
            'name': player_name,
            'hand': [],
            'connected': True
        }
        
        room['players'].append(player)
        join_room(room_code)
        
        emit('room_joined', {
            'room_code': room_code,
            'players': [{'name': p['name'], 'card_count': 0} for p in room['players']]
        })
        
        socketio.emit('player_joined', {
            'player_name': player_name,
            'players': [{'name': p['name'], 'card_count': 0} for p in room['players']]
        }, room=room_code, skip_sid=request.sid)
        
        print(f'üë§ {player_name} –ø—Ä–∏—î–¥–Ω–∞–≤—Å—è –¥–æ {room_code}')
        
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏—î–¥–Ω–∞–Ω–Ω—è –¥–æ –∫—ñ–º–Ω–∞—Ç–∏: {e}')
        emit('error', {'message': '–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏—î–¥–Ω–∞–Ω–Ω—è'})

@socketio.on('leave_room')
def handle_leave_room(data):
    try:
        room_code = data.get('room_code')
        
        if room_code in game_rooms:
            room = game_rooms[room_code]
            player_name = None
            
            for player in room['players']:
                if player['sid'] == request.sid:
                    player_name = player['name']
                    room['players'].remove(player)
                    break
            
            leave_room(room_code)
            
            if player_name:
                socketio.emit('player_left', {
                    'player_name': player_name,
                    'players': [{'name': p['name'], 'card_count': len(p.get('hand', []))} for p in room['players']]
                }, room=room_code)
            
            if len(room['players']) == 0:
                del game_rooms[room_code]
                print(f'üóëÔ∏è –ö—ñ–º–Ω–∞—Ç–∞ {room_code} –≤–∏–¥–∞–ª–µ–Ω–∞')
                
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ –≤–∏—Ö–æ–¥—É –∑ –∫—ñ–º–Ω–∞—Ç–∏: {e}')

@socketio.on('start_game')
def handle_start_game(data):
    try:
        room_code = data.get('room_code')
        
        if room_code not in game_rooms:
            emit('error', {'message': '–ö—ñ–º–Ω–∞—Ç—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ'})
            return
        
        room = game_rooms[room_code]
        
        if request.sid != room['host']:
            emit('error', {'message': '–¢—ñ–ª—å–∫–∏ —Ö–æ—Å—Ç –º–æ–∂–µ –ø–æ—á–∞—Ç–∏ –≥—Ä—É'})
            return
        
        if len(room['players']) < 2:
            emit('error', {'message': '–ü–æ—Ç—Ä—ñ–±–Ω–æ –º—ñ–Ω—ñ–º—É–º 2 –≥—Ä–∞–≤—Ü—ñ'})
            return
        
        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≥—Ä–∏
        room['deck'] = create_deck()
        room['trump_suit'] = room['deck'][-1]['suit']
        room['game_started'] = True
        room['table_cards'] = []
        room['current_turn'] = 0
        room['attacker_index'] = 0
        room['defender_index'] = 1
        
        # –†–æ–∑–¥–∞—á–∞ –∫–∞—Ä—Ç
        for player in room['players']:
            player['hand'] = []
            for _ in range(6):
                if room['deck']:
                    player['hand'].append(room['deck'].pop(0))
        
        # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–∏—Ö –∫–æ–∂–Ω–æ–º—É –≥—Ä–∞–≤—Ü—é
        for player in room['players']:
            socketio.emit('game_started', {
                'hand': player['hand'],
                'trump_suit': room['trump_suit'],
                'deck_count': len(room['deck']),
                'current_turn': room['players'][room['current_turn']]['name'],
                'players': [{'name': p['name'], 'card_count': len(p['hand'])} for p in room['players']]
            }, to=player['sid'])
        
        print(f'üé≤ –ì—Ä–∞ –ø–æ—á–∞–ª–∞—Å—è –≤ –∫—ñ–º–Ω–∞—Ç—ñ {room_code}')
        
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ —Å—Ç–∞—Ä—Ç—É –≥—Ä–∏: {e}')
        emit('error', {'message': '–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É –≥—Ä–∏'})

@socketio.on('play_card')
def handle_play_card(data):
    try:
        room_code = data.get('room_code')
        action = data.get('action')
        cards = data.get('cards', [])
        
        if room_code not in game_rooms:
            return
        
        room = game_rooms[room_code]
        player_index = None
        
        for i, player in enumerate(room['players']):
            if player['sid'] == request.sid:
                player_index = i
                break
        
        if player_index is None:
            return
        
        current_player = room['players'][player_index]
        
        # –û–±—Ä–æ–±–∫–∞ –¥—ñ–π
        if action == 'throw':
            for card in cards:
                for hand_card in current_player['hand']:
                    if hand_card['value'] == card['value'] and hand_card['suit'] == card['suit']:
                        current_player['hand'].remove(hand_card)
                        room['table_cards'].append({'attack': card, 'defense': None})
                        break
            
            socketio.emit('card_played', {
                'player': current_player['name'],
                'action': 'throw'
            }, room=room_code)
        
        elif action == 'take':
            # –ì—Ä–∞–≤–µ—Ü—å –±–µ—Ä–µ –≤—Å—ñ –∫–∞—Ä—Ç–∏ –∑—ñ —Å—Ç–æ–ª—É
            for pair in room['table_cards']:
                current_player['hand'].append(pair['attack'])
                if pair['defense']:
                    current_player['hand'].append(pair['defense'])
            
            room['table_cards'] = []
            
            socketio.emit('chat_message', {
                'player': '–°–∏—Å—Ç–µ–º–∞',
                'message': f'{current_player["name"]} –≤–∑—è–≤ –∫–∞—Ä—Ç–∏'
            }, room=room_code)
        
        elif action == 'pass':
            # –ü–µ—Ä–µ—Ö—ñ–¥ —Ö–æ–¥—É
            room['table_cards'] = []
            room['current_turn'] = (room['current_turn'] + 1) % len(room['players'])
        
        # –î–æ—Ä–æ–∑–¥–∞—á–∞ –∫–∞—Ä—Ç
        for player in room['players']:
            while len(player['hand']) < 6 and room['deck']:
                player['hand'].append(room['deck'].pop(0))
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –≥—Ä–∏
        winner = None
        for player in room['players']:
            if len(player['hand']) == 0 and len(room['deck']) == 0:
                winner = player['name']
                break
        
        if winner:
            socketio.emit('game_over', {'winner': winner}, room=room_code)
            room['game_started'] = False
            return
        
        # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
        for player in room['players']:
            socketio.emit('game_state_update', {
                'hand': player['hand'],
                'table_cards': room['table_cards'],
                'deck_count': len(room['deck']),
                'current_turn': room['players'][room['current_turn']]['name'],
                'players': [{'name': p['name'], 'card_count': len(p['hand'])} for p in room['players']]
            }, to=player['sid'])
            
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ –≥—Ä–∏: {e}')

@socketio.on('chat_message')
def handle_chat_message(data):
    try:
        room_code = data.get('room_code')
        message = data.get('message', '')
        
        if room_code in game_rooms:
            player_name = None
            for player in game_rooms[room_code]['players']:
                if player['sid'] == request.sid:
                    player_name = player['name']
                    break
            
            if player_name:
                socketio.emit('chat_message', {
                    'player': player_name,
                    'message': message
                }, room=room_code)
                
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ —á–∞—Ç—É: {e}')

@socketio.on('random_event')
def handle_random_event(data):
    try:
        room_code = data.get('room_code')
        event_type = data.get('event')
        
        if room_code not in game_rooms:
            return
        
        room = game_rooms[room_code]
        
        if event_type == 'trump_change':
            room['trump_suit'] = random.choice(SUITS)
            socketio.emit('special_event', {
                'event': 'trump_change',
                'message': f'–ù–æ–≤–∏–π –∫–æ–∑–∏—Ä: {room["trump_suit"]}'
            }, room=room_code)
        
        elif event_type == 'drunk_dealer':
            for player in room['players']:
                if room['deck']:
                    player['hand'].append(room['deck'].pop(0))
            
            socketio.emit('special_event', {
                'event': 'drunk_dealer',
                'message': '–ü\'—è–Ω–∏–π –¥–∏–ª–µ—Ä —Ä–æ–∑–¥–∞–≤ –∫–∞—Ä—Ç–∏!'
            }, room=room_code)
        
        elif event_type == 'matrix_error':
            for player in room['players']:
                random.shuffle(player['hand'])
            
            socketio.emit('special_event', {
                'event': 'matrix_error',
                'message': '–ö–∞—Ä—Ç–∏ –ø–µ—Ä–µ–º—ñ—à–∞–Ω–æ!'
            }, room=room_code)
        
        elif event_type == 'light_flicker':
            if room['players']:
                random_player = random.choice(room['players'])
                if random_player['hand']:
                    random_player['hand'].pop(random.randint(0, len(random_player['hand']) - 1))
            
            socketio.emit('special_event', {
                'event': 'light_flicker',
                'message': '–•—Ç–æ—Å—å –≤—Ç—Ä–∞—Ç–∏–≤ –∫–∞—Ä—Ç—É!'
            }, room=room_code)
            
    except Exception as e:
        print(f'–ü–æ–º–∏–ª–∫–∞ —Å–ø–µ—Ü–ø–æ–¥—ñ—ó: {e}')

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    print(f'üé¥ –î—É—Ä–∞–∫ —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω–æ –Ω–∞ –ø–æ—Ä—Ç—ñ {port}')
    print(f'üìä –†–µ–∂–∏–º: {"Production" if not app.debug else "Development"}')
    socketio.run(
        app,
        host='0.0.0.0',
        port=port,
        debug=False,
        allow_unsafe_werkzeug=True
    )
